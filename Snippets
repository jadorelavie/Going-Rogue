import Foundation
import CloudKit
import UIKit
import CoreLocation
import MapKit

//***TASKS to COMPLETE:***
//Please add status to the user class. Let's remove Task from the Impact enum and use it for both the project and task classes. Let's also make Impact multi-select in both project and task classes.

import Foundation

class User {
    var id: UUID
    var name: String
    var role: String
    var jobTitle: String
    var schedule: Schedule

    init(name: String, role: String, jobTitle: String, schedule: Schedule) {
        self.id = UUID()
        self.name = name
        self.role = role
        self.jobTitle = jobTitle
        self.schedule = schedule
    }
}

enum TaskImpact: Int {
    case low = 1
    case medium = 2
    case high = 3
}

enum TaskUrgency: Int {
    case notUrgent = 1
    case timeSensitive = 2
    case missionCritical = 3
}

class Task {
    var id: UUID
    var title: String
    var description: String
    var status: String
    var accountableUserId: UUID
    var responsibleUserIds: [UUID]
    var projectIds: [UUID]
    var dueDate: Date
    var reviewDate: Date
    var impact: TaskImpact
    var urgency: TaskUrgency
    var tags: [String]

    init(title: String, description: String, status: String, accountableUserId: UUID, responsibleUserIds: [UUID], projectIds: [UUID], dueDate: Date, reviewDate: Date, impact: TaskImpact, urgency: TaskUrgency, tags: [String]) {
        self.id = UUID()
        self.title = title
        self.description = description
        self.status = status
        self.accountableUserId = accountableUserId
        self.responsibleUserIds = responsibleUserIds
        self.projectIds = projectIds
        self.dueDate = dueDate
        self.reviewDate = reviewDate
        self.impact = impact
        self.urgency = urgency
        self.tags = tags
    }
}

class Project {
    var id: UUID
    var name: String
    var status: String
    var dueDate: Date
    var reviewDate: Date
    var impact: TaskImpact

    init(name: String, status: String, dueDate: Date, reviewDate: Date, impact: TaskImpact) {
        self.id = UUID()
        self.name = name
        self.status = status
        self.dueDate = dueDate
        self.reviewDate = reviewDate
        self.impact = impact
    }
}


    // ****Add CloudKit interactions here
}

// Schedule class
class Schedule {
    var workHours: [String: (start: Date, end: Date)]

    init() {
        self.workHours = [:]
    }

    func setWorkHours(for day: String, start: Date, end: Date) {
        workHours[day] = (start, end)
    }

    func getWorkHours(for day: String) -> (Date, Date)? {
        return workHours[day]
    }
}

enum ScheduleRequestStatus: String {
    case pending = "Pending"
    case approved = "Approved"
    case rejected = "Rejected"
}

class ScheduleRequest {
    var id: UUID
    var employeeId: UUID
    var day: String
    var newStart: Date
    var newEnd: Date
    var status: ScheduleRequestStatus

    init(employeeId: UUID, day: String, newStart: Date, newEnd: Date) {
        self.id = UUID()
        self.employeeId = employeeId
        self.day = day
        self.newStart = newStart
        self.newEnd = newEnd
        self.status = .pending
    }

    // Add CloudKit interactions here
}

extension ScheduleRequest {
    func toCKRecord() -> CKRecord {
        let recordID = CKRecord.ID(recordName: id.uuidString)
        let record = CKRecord(recordType: "ScheduleRequest", recordID: recordID)

        record["employeeId"] = employeeId.uuidString as CKRecordValue
        record["day"] = day as CKRecordValue
        record["newStart"] = newStart as CKRecordValue
        record["newEnd"] = newEnd as CKRecordValue
        record["status"] = status.rawValue as CKRecordValue

        return record
    }

    static func fromCKRecord(record: CKRecord) -> ScheduleRequest? {
        guard let employeeIdString = record["employeeId"] as? String,
              let employeeId = UUID(uuidString: employeeIdString),
              let day = record["day"] as? String,
              let newStart = record["newStart"] as? Date,
              let newEnd = record["newEnd"] as? Date,
              let statusString = record["status"] as? String,
              let status = ScheduleRequestStatus(rawValue: statusString)
        else {
            return


class YourViewController: UIViewController, CLLocationManagerDelegate {
    
    private var locationManager: CLLocationManager?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Create the button programmatically if not using a storyboard
        let reportLateButton = UIButton(type: .system)
        reportLateButton.setTitle("Report Late", for: .normal)
        reportLateButton.addTarget(self, action: #selector(reportLateButtonTapped), for: .touchUpInside)
        reportLateButton.frame = CGRect(x: 100, y: 100, width: 200, height: 40)
        view.addSubview(reportLateButton)
    }
    
    @objc func reportLateButtonTapped() {
        requestLocationPermission()
    }
    
    private func requestLocationPermission() {
        locationManager = CLLocationManager()
        locationManager?.delegate = self
        locationManager?.requestWhenInUseAuthorization()
    }
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        if status == .authorizedWhenInUse {
            locationManager?.requestLocation()
        } else if status != .notDetermined {
            showAlert(message: "Location permission is required to report late.")
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let currentLocation = locations.first else { return }
        
        let farmAddress = "137 Fairweather Lane, Lancaster, VA 22503"
        let geocoder = CLGeocoder()
        geocoder.geocodeAddressString(farmAddress) { placemarks, error in
            if let error = error {
                print("Error geocoding address: \(error.localizedDescription)")
                return
            }
            
            if let destinationLocation = placemarks?.first?.location {
                self.calculateRoute(currentLocation: currentLocation, destinationLocation: destinationLocation.coordinate)
            } else {
                print("Unable to find the destination location.")
            }
        }
    }
    
    private func calculateRoute(currentLocation: CLLocation, destinationLocation: CLLocationCoordinate2D) {
        let request = MKDirections.Request()
        request.source = MKMapItem(placemark: MKPlacemark(coordinate: currentLocation.coordinate))
        request.destination = MKMapItem(placemark: MKPlacemark(coordinate: destinationLocation))
        request.transportType = .automobile

        let directions = MKDirections(request: request)
        directions.calculate { response, error in
            if let error = error {
                print("Error calculating route: \(error.localizedDescription)")
                return
            }

            if let route = response?.routes.first {
                let travelTime = route.expectedTravelTime
                let timeInMinutes = Int(travelTime / 60)
                self.reportLateMessage(timeInMinutes: timeInMinutes, currentLocation: currentLocation)
            }
        }
    }
    
    private func reportLateMessage(timeInMinutes: Int, currentLocation: CLLocation) {
        // Share the information with the concerned person or store it in CloudKit
        print("Employee is running late by \(timeInMinutes) minutes. Current location: \(currentLocation.coordinate.latitude), \(currentLocation.coordinate.longitude)")
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("Error fetching location: \(error.localizedDescription)")
   
